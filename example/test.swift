// Generated by https://github.com/alecthomas/prototemplate.  DO NOT EDIT!

import Foundation
// This generated code relies on the serialization layer of
// https://github.com/alexeyxo/protobuf-swift
import ProtocolBuffers

// Extend protobuf-swift's Message to include deserialization directly, rather
// than via a MessageBuilder.
public protocol ProtobufMessage: Message {
  class func fromCodedInputStream(input: CodedInputStream) -> Self?
  class func fromData(data: NSData) -> Self?
}


public enum Role: Int32 {
  case Executive = 1
  case Manager = 2
  case Employee = 3
}

public func == (lhs: User, rhs: User) -> Bool {
  if lhs.name != rhs.name { return false }
  if lhs.age != rhs.age { return false }
  if lhs.roles != rhs.roles { return false }
  return true
}

public final class User: AbstractMessage, ProtobufMessage {
  public let name: String
  public let age: Int64?
  public let roles: [Role]

  public init(name: String, age: Int64? = 18, roles: [Role] = []) {
    self.name = name
    self.age = age
    self.roles = roles
    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> User? {
    var name: String?
    var age: Int64?
    var roles: [Role] = []

    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop

      case 10:
        name = input.readString()

      case 16:
        age = input.readInt64()

      case 24:
        let n = input.readEnum()
        if let v = Role(rawValue: n) {
          roles.append(v)
        } else {
          return nil
        }


      default:
        return nil
      }
    }
    if name == nil { return nil }
    return User(name: name!, age: age, roles: roles)
  }

  public class func fromData(data: NSData) -> User? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
    output.writeString(1, value: name)
    if age != nil { output.writeInt64(2, value: age!) }
    for v in roles { output.writeEnum(3, value: v.rawValue) }
  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
    size += name.computeStringSize(1);
    if age != nil { size += age!.computeInt64Size(2); }
    size += roles.map({v in v.rawValue.computeEnumSize(3)}).reduce(0, +);
    return size
  }
}

public func == (lhs: Group, rhs: Group) -> Bool {
  if lhs.owner != rhs.owner { return false }
  if lhs.users != rhs.users { return false }
  return true
}

public final class Group: AbstractMessage, ProtobufMessage {
  public let owner: User
  public let users: [User]

  public init(owner: User, users: [User] = []) {
    self.owner = owner
    self.users = users
    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> Group? {
    var owner: User?
    var users: [User] = []

    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop

      case 10:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = User.fromCodedInputStream(input) {
          owner = v
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      case 18:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = User.fromCodedInputStream(input) {
          users.append(v)
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      default:
        return nil
      }
    }
    if owner == nil { return nil }
    return Group(owner: owner!, users: users)
  }

  public class func fromData(data: NSData) -> Group? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
    output.writeMessage(1, value: owner)
    for v in users { output.writeMessage(2, value: v) }
  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
    size += owner.computeMessageSize(1);
    size += users.map({v in v.computeMessageSize(2)}).reduce(0, +);
    return size
  }
}






