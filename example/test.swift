// Generated by https://github.com/alecthomas/prototemplate.  DO NOT EDIT!

import Foundation
// This generated code relies on the serialization layer of
// https://github.com/alexeyxo/protobuf-swift
import ProtocolBuffers

// Extend protobuf-swift's Message to include deserialization directly, rather
// than via a MessageBuilder.
public protocol ProtobufMessage: Message {
  class func fromCodedInputStream(input: CodedInputStream) -> Self?
  class func fromData(data: NSData) -> Self?
}


public enum Role: Int32 {
  case Executive = 1
  case Manager = 2
  case Employee = 3
}


public func == (lhs: User, rhs: User) -> Bool {
  if lhs.name != rhs.name { return false }
  if lhs.age != rhs.age { return false }
  if lhs.roles != rhs.roles { return false }
  return true
}

public final class User: AbstractMessage, ProtobufMessage {

  public let name: String
  public let age: Int64?
  public let roles: [Role]


  public init(name: String, age: Int64? = 18, roles: [Role] = []) {
    self.name = name
    self.age = age
    self.roles = roles
    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> User? {
    var name: String?
    var age: Int64?
    var roles: [Role] = []

    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop

      case 10:
        name = input.readString()

      case 16:
        age = input.readInt64()

      case 24:
        let n = input.readEnum()
        if let v = Role(rawValue: n) {
          roles.append(v)
        } else {
          return nil
        }


      default:
        return nil
      }
    }
    if name == nil { return nil }
    return User(name: name!, age: age, roles: roles)
  }

  public class func fromData(data: NSData) -> User? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
    output.writeString(1, value: name)
    if age != nil { output.writeInt64(2, value: age!) }
    for v in roles { output.writeEnum(3, value: v.rawValue) }
  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
    size += name.computeStringSize(1);
    if age != nil { size += age!.computeInt64Size(2); }
    size += roles.map({v in v.rawValue.computeEnumSize(3)}).reduce(0, +);
    return size
  }
}


public func == (lhs: Group, rhs: Group) -> Bool {
  if lhs.owner != rhs.owner { return false }
  if lhs.users != rhs.users { return false }
  return true
}

public final class Group: AbstractMessage, ProtobufMessage {

  public let owner: User
  public let users: [User]


  public init(owner: User, users: [User] = []) {
    self.owner = owner
    self.users = users
    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> Group? {
    var owner: User?
    var users: [User] = []

    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop

      case 10:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = User.fromCodedInputStream(input) {
          owner = v
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      case 18:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = User.fromCodedInputStream(input) {
          users.append(v)
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      default:
        return nil
      }
    }
    if owner == nil { return nil }
    return Group(owner: owner!, users: users)
  }

  public class func fromData(data: NSData) -> Group? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
    output.writeMessage(1, value: owner)
    for v in users { output.writeMessage(2, value: v) }
  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
    size += owner.computeMessageSize(1);
    size += users.map({v in v.computeMessageSize(2)}).reduce(0, +);
    return size
  }
}


public func == (lhs: GroupOrUser, rhs: GroupOrUser) -> Bool {
  if lhs.user != rhs.user { return false }
  if lhs.group != rhs.group { return false }
  if lhs.role != rhs.role { return false }
  return true
}

public final class GroupOrUser: AbstractMessage, ProtobufMessage {
  public enum Union {
    case User(User)
    case Group(Group)
  }

  private static func unionFromElements(user: user: User? = nil, group: group: Group? = nil) -> Union? {
    if let v = user { return .User(v) }
    if let v = group { return .Group(v) }
    return nil
  }

  private let user: User?
  private let group: Group?
  public let role: Role?

  public var union: Union? {
    return unionFromElements(user: user, group: group)
  }

  public init(role: Role? = nil, union: Union? = nil) {
    self.role = role
    if let unwrapped = union {
      switch unwrapped {
      case let .User(v):
        user = v
      case let .Group(v):
        group = v
      }
    }
    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> GroupOrUser? {
    var user: User?
    var group: Group?
    var role: Role?

    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop

      case 10:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = User.fromCodedInputStream(input) {
          user = v
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      case 18:
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = Group.fromCodedInputStream(input) {
          group = v
          input.popLimit(oldLimit)
        } else {
          return nil
        }

      case 24:
        let n = input.readEnum()
        if let v = Role(rawValue: n) {
          role = v
        } else {
          return nil
        }


      default:
        return nil
      }
    }
    let union = unionFromElements(user, group)
    return GroupOrUser(role: role, union: union)
  }

  public class func fromData(data: NSData) -> GroupOrUser? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
    if user != nil { output.writeMessage(1, value: user!) }
    if group != nil { output.writeMessage(2, value: group!) }
    if role != nil { output.writeEnum(3, value: role!.rawValue) }
  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
    if user != nil { size += user!.computeMessageSize(1); }
    if group != nil { size += group!.computeMessageSize(2); }
    if role != nil { size += role!.rawValue.computeEnumSize(3); }
    return size
  }
}







