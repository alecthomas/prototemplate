// Generated by https://github.com/alecthomas/prototemplate.  DO NOT EDIT!

import Foundation
// This generated code relies on the serialization layer of
// https://github.com/alexeyxo/protobuf-swift
import ProtocolBuffers

// Extend protobuf-swift's Message to include deserialization directly, rather
// than via a MessageBuilder.
public protocol ProtobufMessage: Message {
  class func fromCodedInputStream(input: CodedInputStream) -> Self?
  class func fromData(data: NSData) -> Self?
}

{{with .FileDescriptorSet}}\
{{range .File}}\
{{range .EnumType}}
public enum {{.Name|Type}}: Int32 {
{{range .Value}}\
  case {{.Name|Const}} = {{.Number}}
{{end}}}
{{end}}\

{{range .MessageType}}
public func == (lhs: {{.Name|Type}}, rhs: {{.Name|Type}}) -> Bool {
{{range .Field}}\
  if lhs.{{.Name|Var}} != rhs.{{.Name|Var}} { return false }
{{end}}\
  return true
}

public final class {{.Name|Type}}: AbstractMessage, ProtobufMessage {
{{range .Field}}\
  public let {{.|FieldDecl}}
{{end}}
  public init({{range $index, $field := .Field}}\
{{if $index}}, {{end}}\
{{$field|FieldDecl}}\
{{if .DefaultValue}} = {{.DefaultValue}}{{else if $field|IsOptional}}\
 = nil{{else if $field|IsRepeated}}\
 = []{{end}}\
{{end}}) {
{{range .Field}}    self.{{.Name|Var}} = {{.Name|Var}}
{{end}}    super.init()
  }

  public class func fromCodedInputStream(input: CodedInputStream) -> {{.Name|Type}}? {
{{range .Field}}    var {{.|OptionalFieldDecl}}
{{end}}
    loop: while (true) {
      var tag = input.readTag()
      switch tag {
      case 0:
        break loop
{{range .Field}}
      case {{.|FieldTag}}:
{{if .|IsEnum}}\
        let n = input.readEnum()
        if let v = {{.TypeName|FixRef|Type}}(rawValue: n) {
{{if .|IsRepeated}}\
          {{.Name|Var}}.append(v)
{{else}}\
          {{.Name|Var}} = v
{{end}}\
        } else {
          return nil
        }

{{else if .|IsMessage}}\
        let oldLimit =  input.pushLimit(input.readRawVarint32())
        if let v = {{.TypeName|FixRef}}.fromCodedInputStream(input) {
{{if .|IsRepeated}}\
          {{.Name|Var}}.append(v)
{{else}}\
          {{.Name|Var}} = v
{{end}}\
          input.popLimit(oldLimit)
        } else {
          return nil
        }
{{else}}\
{{if .|IsRepeated}}\
        {{.Name|Var}}.append(input.read{{.|TypeToProtocolBuffer}}())
{{else}}\
        {{.Name|Var}} = input.read{{.|TypeToProtocolBuffer}}()
{{end}}\
{{end}}\
{{end}}
      default:
        return nil
      }
    }
{{range .Field}}\
{{if .|IsRequired}}\
    if {{.Name|Var}} == nil { return nil }
{{end}}\
{{end}}\
    return {{.Name|Type}}\
({{range $index, $field := .Field}}\
{{if $index}}, {{end}}\
{{$field.Name|Var}}: {{$field.Name|Var}}\
{{if .|IsRequired}}\!{{end}}\
{{end}})
  }

  public class func fromData(data: NSData) -> {{.Name|Type}}? {
      var input = CodedInputStream(data: data)
      return fromCodedInputStream(input)
  }

  public required init() {
    fatalError("init() has not been implemented")
  }

  override public func isInitialized() -> Bool { return true }

  override public func writeToCodedOutputStream(output: CodedOutputStream) {
{{range .Field}}\
    {{.|WriteFieldToOutput}}
{{end}}  }

  override public func serializedSize() -> Int32 {
    var size: Int32 = 0
{{range .Field}}\
    {{if .|IsOptional}}if {{.Name|Var}} != nil { {{end}}\
size += {{.|ComputeSizeCall}};{{if .|IsOptional}} }{{end}}
{{end}}\
    return size
  }
}
{{end}}

{{range .Service}}
public protocol {{.Name}} {
{{range .Method}}  func {{.Name}}(req: {{.InputType|FixRef}}) -> {{.OutputType|FixRef}}?
{{end}}}
{{end}}

{{end}}
{{end}}
